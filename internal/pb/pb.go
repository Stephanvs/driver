// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: api.proto

package pb

import proto "github.com/gogo/protobuf/proto"
import golang_proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "github.com/gogo/protobuf/gogoproto"
import types "github.com/gogo/protobuf/types"

import github_com_pjvds_streamsdb_api_wire "github.com/streamsdb/driver/internal/wire"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = golang_proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

type LoginRequest struct {
	Username string `protobuf:"bytes,1,opt,name=username,proto3" json:"username,omitempty"`
	Password string `protobuf:"bytes,2,opt,name=password,proto3" json:"password,omitempty"`
}

func (m *LoginRequest) Reset()         { *m = LoginRequest{} }
func (m *LoginRequest) String() string { return proto.CompactTextString(m) }
func (*LoginRequest) ProtoMessage()    {}
func (*LoginRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_api_f7ebe764f5fe0ecb, []int{0}
}
func (m *LoginRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LoginRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LoginRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *LoginRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LoginRequest.Merge(dst, src)
}
func (m *LoginRequest) XXX_Size() int {
	return m.Size()
}
func (m *LoginRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_LoginRequest.DiscardUnknown(m)
}

var xxx_messageInfo_LoginRequest proto.InternalMessageInfo

func (m *LoginRequest) GetUsername() string {
	if m != nil {
		return m.Username
	}
	return ""
}

func (m *LoginRequest) GetPassword() string {
	if m != nil {
		return m.Password
	}
	return ""
}

type LoginReply struct {
	Token string `protobuf:"bytes,1,opt,name=token,proto3" json:"token,omitempty"`
}

func (m *LoginReply) Reset()         { *m = LoginReply{} }
func (m *LoginReply) String() string { return proto.CompactTextString(m) }
func (*LoginReply) ProtoMessage()    {}
func (*LoginReply) Descriptor() ([]byte, []int) {
	return fileDescriptor_api_f7ebe764f5fe0ecb, []int{1}
}
func (m *LoginReply) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LoginReply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LoginReply.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *LoginReply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LoginReply.Merge(dst, src)
}
func (m *LoginReply) XXX_Size() int {
	return m.Size()
}
func (m *LoginReply) XXX_DiscardUnknown() {
	xxx_messageInfo_LoginReply.DiscardUnknown(m)
}

var xxx_messageInfo_LoginReply proto.InternalMessageInfo

func (m *LoginReply) GetToken() string {
	if m != nil {
		return m.Token
	}
	return ""
}

type EnableAclRequest struct {
	Username  string                                    `protobuf:"bytes,1,opt,name=username,proto3" json:"username,omitempty"`
	Password  string                                    `protobuf:"bytes,2,opt,name=password,proto3" json:"password,omitempty"`
	Signature github_com_pjvds_streamsdb_api_wire.Bytes `protobuf:"bytes,3,opt,name=signature,proto3,customtype=github.com/pjvds/streamsdb/api/wire.Bytes" json:"signature"`
}

func (m *EnableAclRequest) Reset()         { *m = EnableAclRequest{} }
func (m *EnableAclRequest) String() string { return proto.CompactTextString(m) }
func (*EnableAclRequest) ProtoMessage()    {}
func (*EnableAclRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_api_f7ebe764f5fe0ecb, []int{2}
}
func (m *EnableAclRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EnableAclRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EnableAclRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *EnableAclRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EnableAclRequest.Merge(dst, src)
}
func (m *EnableAclRequest) XXX_Size() int {
	return m.Size()
}
func (m *EnableAclRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_EnableAclRequest.DiscardUnknown(m)
}

var xxx_messageInfo_EnableAclRequest proto.InternalMessageInfo

func (m *EnableAclRequest) GetUsername() string {
	if m != nil {
		return m.Username
	}
	return ""
}

func (m *EnableAclRequest) GetPassword() string {
	if m != nil {
		return m.Password
	}
	return ""
}

type GetCollectionRequest struct {
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
}

func (m *GetCollectionRequest) Reset()         { *m = GetCollectionRequest{} }
func (m *GetCollectionRequest) String() string { return proto.CompactTextString(m) }
func (*GetCollectionRequest) ProtoMessage()    {}
func (*GetCollectionRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_api_f7ebe764f5fe0ecb, []int{3}
}
func (m *GetCollectionRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetCollectionRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetCollectionRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *GetCollectionRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetCollectionRequest.Merge(dst, src)
}
func (m *GetCollectionRequest) XXX_Size() int {
	return m.Size()
}
func (m *GetCollectionRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetCollectionRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetCollectionRequest proto.InternalMessageInfo

func (m *GetCollectionRequest) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

type GetCollectionReply struct {
	Id   uint32 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	Name string `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
}

func (m *GetCollectionReply) Reset()         { *m = GetCollectionReply{} }
func (m *GetCollectionReply) String() string { return proto.CompactTextString(m) }
func (*GetCollectionReply) ProtoMessage()    {}
func (*GetCollectionReply) Descriptor() ([]byte, []int) {
	return fileDescriptor_api_f7ebe764f5fe0ecb, []int{4}
}
func (m *GetCollectionReply) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetCollectionReply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetCollectionReply.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *GetCollectionReply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetCollectionReply.Merge(dst, src)
}
func (m *GetCollectionReply) XXX_Size() int {
	return m.Size()
}
func (m *GetCollectionReply) XXX_DiscardUnknown() {
	xxx_messageInfo_GetCollectionReply.DiscardUnknown(m)
}

var xxx_messageInfo_GetCollectionReply proto.InternalMessageInfo

func (m *GetCollectionReply) GetId() uint32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *GetCollectionReply) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

type EnableAclReply struct {
}

func (m *EnableAclReply) Reset()         { *m = EnableAclReply{} }
func (m *EnableAclReply) String() string { return proto.CompactTextString(m) }
func (*EnableAclReply) ProtoMessage()    {}
func (*EnableAclReply) Descriptor() ([]byte, []int) {
	return fileDescriptor_api_f7ebe764f5fe0ecb, []int{5}
}
func (m *EnableAclReply) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EnableAclReply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EnableAclReply.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *EnableAclReply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EnableAclReply.Merge(dst, src)
}
func (m *EnableAclReply) XXX_Size() int {
	return m.Size()
}
func (m *EnableAclReply) XXX_DiscardUnknown() {
	xxx_messageInfo_EnableAclReply.DiscardUnknown(m)
}

var xxx_messageInfo_EnableAclReply proto.InternalMessageInfo

type GrandUserToCollectionRequest struct {
	Username   string `protobuf:"bytes,1,opt,name=username,proto3" json:"username,omitempty"`
	Collection string `protobuf:"bytes,2,opt,name=collection,proto3" json:"collection,omitempty"`
}

func (m *GrandUserToCollectionRequest) Reset()         { *m = GrandUserToCollectionRequest{} }
func (m *GrandUserToCollectionRequest) String() string { return proto.CompactTextString(m) }
func (*GrandUserToCollectionRequest) ProtoMessage()    {}
func (*GrandUserToCollectionRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_api_f7ebe764f5fe0ecb, []int{6}
}
func (m *GrandUserToCollectionRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GrandUserToCollectionRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GrandUserToCollectionRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *GrandUserToCollectionRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GrandUserToCollectionRequest.Merge(dst, src)
}
func (m *GrandUserToCollectionRequest) XXX_Size() int {
	return m.Size()
}
func (m *GrandUserToCollectionRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GrandUserToCollectionRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GrandUserToCollectionRequest proto.InternalMessageInfo

func (m *GrandUserToCollectionRequest) GetUsername() string {
	if m != nil {
		return m.Username
	}
	return ""
}

func (m *GrandUserToCollectionRequest) GetCollection() string {
	if m != nil {
		return m.Collection
	}
	return ""
}

type GrandUserToCollectionReply struct {
}

func (m *GrandUserToCollectionReply) Reset()         { *m = GrandUserToCollectionReply{} }
func (m *GrandUserToCollectionReply) String() string { return proto.CompactTextString(m) }
func (*GrandUserToCollectionReply) ProtoMessage()    {}
func (*GrandUserToCollectionReply) Descriptor() ([]byte, []int) {
	return fileDescriptor_api_f7ebe764f5fe0ecb, []int{7}
}
func (m *GrandUserToCollectionReply) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GrandUserToCollectionReply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GrandUserToCollectionReply.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *GrandUserToCollectionReply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GrandUserToCollectionReply.Merge(dst, src)
}
func (m *GrandUserToCollectionReply) XXX_Size() int {
	return m.Size()
}
func (m *GrandUserToCollectionReply) XXX_DiscardUnknown() {
	xxx_messageInfo_GrandUserToCollectionReply.DiscardUnknown(m)
}

var xxx_messageInfo_GrandUserToCollectionReply proto.InternalMessageInfo

type CreateUserRequest struct {
	Username string `protobuf:"bytes,1,opt,name=username,proto3" json:"username,omitempty"`
	Password string `protobuf:"bytes,2,opt,name=password,proto3" json:"password,omitempty"`
}

func (m *CreateUserRequest) Reset()         { *m = CreateUserRequest{} }
func (m *CreateUserRequest) String() string { return proto.CompactTextString(m) }
func (*CreateUserRequest) ProtoMessage()    {}
func (*CreateUserRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_api_f7ebe764f5fe0ecb, []int{8}
}
func (m *CreateUserRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CreateUserRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CreateUserRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *CreateUserRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CreateUserRequest.Merge(dst, src)
}
func (m *CreateUserRequest) XXX_Size() int {
	return m.Size()
}
func (m *CreateUserRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_CreateUserRequest.DiscardUnknown(m)
}

var xxx_messageInfo_CreateUserRequest proto.InternalMessageInfo

func (m *CreateUserRequest) GetUsername() string {
	if m != nil {
		return m.Username
	}
	return ""
}

func (m *CreateUserRequest) GetPassword() string {
	if m != nil {
		return m.Password
	}
	return ""
}

type CreateUserReply struct {
}

func (m *CreateUserReply) Reset()         { *m = CreateUserReply{} }
func (m *CreateUserReply) String() string { return proto.CompactTextString(m) }
func (*CreateUserReply) ProtoMessage()    {}
func (*CreateUserReply) Descriptor() ([]byte, []int) {
	return fileDescriptor_api_f7ebe764f5fe0ecb, []int{9}
}
func (m *CreateUserReply) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CreateUserReply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CreateUserReply.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *CreateUserReply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CreateUserReply.Merge(dst, src)
}
func (m *CreateUserReply) XXX_Size() int {
	return m.Size()
}
func (m *CreateUserReply) XXX_DiscardUnknown() {
	xxx_messageInfo_CreateUserReply.DiscardUnknown(m)
}

var xxx_messageInfo_CreateUserReply proto.InternalMessageInfo

type CreateCollectionRequest struct {
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
}

func (m *CreateCollectionRequest) Reset()         { *m = CreateCollectionRequest{} }
func (m *CreateCollectionRequest) String() string { return proto.CompactTextString(m) }
func (*CreateCollectionRequest) ProtoMessage()    {}
func (*CreateCollectionRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_api_f7ebe764f5fe0ecb, []int{10}
}
func (m *CreateCollectionRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CreateCollectionRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CreateCollectionRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *CreateCollectionRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CreateCollectionRequest.Merge(dst, src)
}
func (m *CreateCollectionRequest) XXX_Size() int {
	return m.Size()
}
func (m *CreateCollectionRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_CreateCollectionRequest.DiscardUnknown(m)
}

var xxx_messageInfo_CreateCollectionRequest proto.InternalMessageInfo

func (m *CreateCollectionRequest) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

type CreateCollectionReply struct {
	CollectionId uint32 `protobuf:"varint,1,opt,name=collectionId,proto3" json:"collectionId,omitempty"`
}

func (m *CreateCollectionReply) Reset()         { *m = CreateCollectionReply{} }
func (m *CreateCollectionReply) String() string { return proto.CompactTextString(m) }
func (*CreateCollectionReply) ProtoMessage()    {}
func (*CreateCollectionReply) Descriptor() ([]byte, []int) {
	return fileDescriptor_api_f7ebe764f5fe0ecb, []int{11}
}
func (m *CreateCollectionReply) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CreateCollectionReply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CreateCollectionReply.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *CreateCollectionReply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CreateCollectionReply.Merge(dst, src)
}
func (m *CreateCollectionReply) XXX_Size() int {
	return m.Size()
}
func (m *CreateCollectionReply) XXX_DiscardUnknown() {
	xxx_messageInfo_CreateCollectionReply.DiscardUnknown(m)
}

var xxx_messageInfo_CreateCollectionReply proto.InternalMessageInfo

func (m *CreateCollectionReply) GetCollectionId() uint32 {
	if m != nil {
		return m.CollectionId
	}
	return 0
}

// The request message containing the user's name.
type ReadRequest struct {
	CollectionId uint32 `protobuf:"varint,1,opt,name=collectionId,proto3" json:"collectionId,omitempty"`
	Stream       string `protobuf:"bytes,2,opt,name=stream,proto3" json:"stream,omitempty"`
	From         int64  `protobuf:"varint,3,opt,name=from,proto3" json:"from,omitempty"`
	Count        uint32 `protobuf:"varint,4,opt,name=count,proto3" json:"count,omitempty"`
}

func (m *ReadRequest) Reset()         { *m = ReadRequest{} }
func (m *ReadRequest) String() string { return proto.CompactTextString(m) }
func (*ReadRequest) ProtoMessage()    {}
func (*ReadRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_api_f7ebe764f5fe0ecb, []int{12}
}
func (m *ReadRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ReadRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ReadRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *ReadRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ReadRequest.Merge(dst, src)
}
func (m *ReadRequest) XXX_Size() int {
	return m.Size()
}
func (m *ReadRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ReadRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ReadRequest proto.InternalMessageInfo

func (m *ReadRequest) GetCollectionId() uint32 {
	if m != nil {
		return m.CollectionId
	}
	return 0
}

func (m *ReadRequest) GetStream() string {
	if m != nil {
		return m.Stream
	}
	return ""
}

func (m *ReadRequest) GetFrom() int64 {
	if m != nil {
		return m.From
	}
	return 0
}

func (m *ReadRequest) GetCount() uint32 {
	if m != nil {
		return m.Count
	}
	return 0
}

type Message struct {
	Type      string                                    `protobuf:"bytes,1,opt,name=type,proto3" json:"type,omitempty"`
	Timestamp *types.Timestamp                          `protobuf:"bytes,2,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
	Metadata  github_com_pjvds_streamsdb_api_wire.Bytes `protobuf:"bytes,3,opt,name=metadata,proto3,customtype=github.com/pjvds/streamsdb/api/wire.Bytes" json:"metadata"`
	Value     github_com_pjvds_streamsdb_api_wire.Bytes `protobuf:"bytes,4,opt,name=value,proto3,customtype=github.com/pjvds/streamsdb/api/wire.Bytes" json:"value"`
}

func (m *Message) Reset()         { *m = Message{} }
func (m *Message) String() string { return proto.CompactTextString(m) }
func (*Message) ProtoMessage()    {}
func (*Message) Descriptor() ([]byte, []int) {
	return fileDescriptor_api_f7ebe764f5fe0ecb, []int{13}
}
func (m *Message) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Message) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Message.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *Message) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Message.Merge(dst, src)
}
func (m *Message) XXX_Size() int {
	return m.Size()
}
func (m *Message) XXX_DiscardUnknown() {
	xxx_messageInfo_Message.DiscardUnknown(m)
}

var xxx_messageInfo_Message proto.InternalMessageInfo

func (m *Message) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *Message) GetTimestamp() *types.Timestamp {
	if m != nil {
		return m.Timestamp
	}
	return nil
}

type Slice struct {
	Stream   string     `protobuf:"bytes,1,opt,name=stream,proto3" json:"stream,omitempty"`
	From     int64      `protobuf:"varint,2,opt,name=from,proto3" json:"from,omitempty"`
	To       int64      `protobuf:"varint,3,opt,name=to,proto3" json:"to,omitempty"`
	Count    int32      `protobuf:"varint,4,opt,name=count,proto3" json:"count,omitempty"`
	Next     int64      `protobuf:"varint,5,opt,name=next,proto3" json:"next,omitempty"`
	HasNext  bool       `protobuf:"varint,6,opt,name=hasNext,proto3" json:"hasNext,omitempty"`
	Head     int64      `protobuf:"varint,7,opt,name=head,proto3" json:"head,omitempty"`
	Messages []*Message `protobuf:"bytes,8,rep,name=messages,proto3" json:"messages,omitempty"`
}

func (m *Slice) Reset()         { *m = Slice{} }
func (m *Slice) String() string { return proto.CompactTextString(m) }
func (*Slice) ProtoMessage()    {}
func (*Slice) Descriptor() ([]byte, []int) {
	return fileDescriptor_api_f7ebe764f5fe0ecb, []int{14}
}
func (m *Slice) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Slice) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Slice.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *Slice) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Slice.Merge(dst, src)
}
func (m *Slice) XXX_Size() int {
	return m.Size()
}
func (m *Slice) XXX_DiscardUnknown() {
	xxx_messageInfo_Slice.DiscardUnknown(m)
}

var xxx_messageInfo_Slice proto.InternalMessageInfo

func (m *Slice) GetStream() string {
	if m != nil {
		return m.Stream
	}
	return ""
}

func (m *Slice) GetFrom() int64 {
	if m != nil {
		return m.From
	}
	return 0
}

func (m *Slice) GetTo() int64 {
	if m != nil {
		return m.To
	}
	return 0
}

func (m *Slice) GetCount() int32 {
	if m != nil {
		return m.Count
	}
	return 0
}

func (m *Slice) GetNext() int64 {
	if m != nil {
		return m.Next
	}
	return 0
}

func (m *Slice) GetHasNext() bool {
	if m != nil {
		return m.HasNext
	}
	return false
}

func (m *Slice) GetHead() int64 {
	if m != nil {
		return m.Head
	}
	return 0
}

func (m *Slice) GetMessages() []*Message {
	if m != nil {
		return m.Messages
	}
	return nil
}

type MessageInput struct {
	Type     string                                    `protobuf:"bytes,1,opt,name=type,proto3" json:"type,omitempty"`
	Metadata github_com_pjvds_streamsdb_api_wire.Bytes `protobuf:"bytes,2,opt,name=metadata,proto3,customtype=github.com/pjvds/streamsdb/api/wire.Bytes" json:"metadata"`
	Value    github_com_pjvds_streamsdb_api_wire.Bytes `protobuf:"bytes,3,opt,name=value,proto3,customtype=github.com/pjvds/streamsdb/api/wire.Bytes" json:"value"`
}

func (m *MessageInput) Reset()         { *m = MessageInput{} }
func (m *MessageInput) String() string { return proto.CompactTextString(m) }
func (*MessageInput) ProtoMessage()    {}
func (*MessageInput) Descriptor() ([]byte, []int) {
	return fileDescriptor_api_f7ebe764f5fe0ecb, []int{15}
}
func (m *MessageInput) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MessageInput) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MessageInput.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *MessageInput) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MessageInput.Merge(dst, src)
}
func (m *MessageInput) XXX_Size() int {
	return m.Size()
}
func (m *MessageInput) XXX_DiscardUnknown() {
	xxx_messageInfo_MessageInput.DiscardUnknown(m)
}

var xxx_messageInfo_MessageInput proto.InternalMessageInfo

func (m *MessageInput) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

type AppendRequest struct {
	CollectionId uint32          `protobuf:"varint,1,opt,name=collectionId,proto3" json:"collectionId,omitempty"`
	Stream       string          `protobuf:"bytes,2,opt,name=stream,proto3" json:"stream,omitempty"`
	Messages     []*MessageInput `protobuf:"bytes,3,rep,name=messages,proto3" json:"messages,omitempty"`
}

func (m *AppendRequest) Reset()         { *m = AppendRequest{} }
func (m *AppendRequest) String() string { return proto.CompactTextString(m) }
func (*AppendRequest) ProtoMessage()    {}
func (*AppendRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_api_f7ebe764f5fe0ecb, []int{16}
}
func (m *AppendRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AppendRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AppendRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *AppendRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AppendRequest.Merge(dst, src)
}
func (m *AppendRequest) XXX_Size() int {
	return m.Size()
}
func (m *AppendRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_AppendRequest.DiscardUnknown(m)
}

var xxx_messageInfo_AppendRequest proto.InternalMessageInfo

func (m *AppendRequest) GetCollectionId() uint32 {
	if m != nil {
		return m.CollectionId
	}
	return 0
}

func (m *AppendRequest) GetStream() string {
	if m != nil {
		return m.Stream
	}
	return ""
}

func (m *AppendRequest) GetMessages() []*MessageInput {
	if m != nil {
		return m.Messages
	}
	return nil
}

type AppendReply struct {
	From int64 `protobuf:"varint,1,opt,name=from,proto3" json:"from,omitempty"`
}

func (m *AppendReply) Reset()         { *m = AppendReply{} }
func (m *AppendReply) String() string { return proto.CompactTextString(m) }
func (*AppendReply) ProtoMessage()    {}
func (*AppendReply) Descriptor() ([]byte, []int) {
	return fileDescriptor_api_f7ebe764f5fe0ecb, []int{17}
}
func (m *AppendReply) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AppendReply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AppendReply.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *AppendReply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AppendReply.Merge(dst, src)
}
func (m *AppendReply) XXX_Size() int {
	return m.Size()
}
func (m *AppendReply) XXX_DiscardUnknown() {
	xxx_messageInfo_AppendReply.DiscardUnknown(m)
}

var xxx_messageInfo_AppendReply proto.InternalMessageInfo

func (m *AppendReply) GetFrom() int64 {
	if m != nil {
		return m.From
	}
	return 0
}

func init() {
	proto.RegisterType((*LoginRequest)(nil), "streamsdb.api.LoginRequest")
	golang_proto.RegisterType((*LoginRequest)(nil), "streamsdb.api.LoginRequest")
	proto.RegisterType((*LoginReply)(nil), "streamsdb.api.LoginReply")
	golang_proto.RegisterType((*LoginReply)(nil), "streamsdb.api.LoginReply")
	proto.RegisterType((*EnableAclRequest)(nil), "streamsdb.api.EnableAclRequest")
	golang_proto.RegisterType((*EnableAclRequest)(nil), "streamsdb.api.EnableAclRequest")
	proto.RegisterType((*GetCollectionRequest)(nil), "streamsdb.api.GetCollectionRequest")
	golang_proto.RegisterType((*GetCollectionRequest)(nil), "streamsdb.api.GetCollectionRequest")
	proto.RegisterType((*GetCollectionReply)(nil), "streamsdb.api.GetCollectionReply")
	golang_proto.RegisterType((*GetCollectionReply)(nil), "streamsdb.api.GetCollectionReply")
	proto.RegisterType((*EnableAclReply)(nil), "streamsdb.api.EnableAclReply")
	golang_proto.RegisterType((*EnableAclReply)(nil), "streamsdb.api.EnableAclReply")
	proto.RegisterType((*GrandUserToCollectionRequest)(nil), "streamsdb.api.GrandUserToCollectionRequest")
	golang_proto.RegisterType((*GrandUserToCollectionRequest)(nil), "streamsdb.api.GrandUserToCollectionRequest")
	proto.RegisterType((*GrandUserToCollectionReply)(nil), "streamsdb.api.GrandUserToCollectionReply")
	golang_proto.RegisterType((*GrandUserToCollectionReply)(nil), "streamsdb.api.GrandUserToCollectionReply")
	proto.RegisterType((*CreateUserRequest)(nil), "streamsdb.api.CreateUserRequest")
	golang_proto.RegisterType((*CreateUserRequest)(nil), "streamsdb.api.CreateUserRequest")
	proto.RegisterType((*CreateUserReply)(nil), "streamsdb.api.CreateUserReply")
	golang_proto.RegisterType((*CreateUserReply)(nil), "streamsdb.api.CreateUserReply")
	proto.RegisterType((*CreateCollectionRequest)(nil), "streamsdb.api.CreateCollectionRequest")
	golang_proto.RegisterType((*CreateCollectionRequest)(nil), "streamsdb.api.CreateCollectionRequest")
	proto.RegisterType((*CreateCollectionReply)(nil), "streamsdb.api.CreateCollectionReply")
	golang_proto.RegisterType((*CreateCollectionReply)(nil), "streamsdb.api.CreateCollectionReply")
	proto.RegisterType((*ReadRequest)(nil), "streamsdb.api.ReadRequest")
	golang_proto.RegisterType((*ReadRequest)(nil), "streamsdb.api.ReadRequest")
	proto.RegisterType((*Message)(nil), "streamsdb.api.Message")
	golang_proto.RegisterType((*Message)(nil), "streamsdb.api.Message")
	proto.RegisterType((*Slice)(nil), "streamsdb.api.Slice")
	golang_proto.RegisterType((*Slice)(nil), "streamsdb.api.Slice")
	proto.RegisterType((*MessageInput)(nil), "streamsdb.api.MessageInput")
	golang_proto.RegisterType((*MessageInput)(nil), "streamsdb.api.MessageInput")
	proto.RegisterType((*AppendRequest)(nil), "streamsdb.api.AppendRequest")
	golang_proto.RegisterType((*AppendRequest)(nil), "streamsdb.api.AppendRequest")
	proto.RegisterType((*AppendReply)(nil), "streamsdb.api.AppendReply")
	golang_proto.RegisterType((*AppendReply)(nil), "streamsdb.api.AppendReply")
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// StreamsClient is the client API for Streams service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type StreamsClient interface {
	GetCollection(ctx context.Context, in *GetCollectionRequest, opts ...grpc.CallOption) (*GetCollectionReply, error)
	Login(ctx context.Context, in *LoginRequest, opts ...grpc.CallOption) (*LoginReply, error)
	EnableAcl(ctx context.Context, in *EnableAclRequest, opts ...grpc.CallOption) (*EnableAclReply, error)
	GrandUserToCollection(ctx context.Context, in *GrandUserToCollectionRequest, opts ...grpc.CallOption) (*GrandUserToCollectionReply, error)
	CreateUser(ctx context.Context, in *CreateUserRequest, opts ...grpc.CallOption) (*CreateUserReply, error)
	CreateCollection(ctx context.Context, in *CreateCollectionRequest, opts ...grpc.CallOption) (*CreateCollectionReply, error)
	// Sends a greeting
	Read(ctx context.Context, in *ReadRequest, opts ...grpc.CallOption) (*Slice, error)
	ReadControl(ctx context.Context, in *ReadRequest, opts ...grpc.CallOption) (*Slice, error)
	Append(ctx context.Context, in *AppendRequest, opts ...grpc.CallOption) (*AppendReply, error)
	Watch(ctx context.Context, in *ReadRequest, opts ...grpc.CallOption) (Streams_WatchClient, error)
}

type streamsClient struct {
	cc *grpc.ClientConn
}

func NewStreamsClient(cc *grpc.ClientConn) StreamsClient {
	return &streamsClient{cc}
}

func (c *streamsClient) GetCollection(ctx context.Context, in *GetCollectionRequest, opts ...grpc.CallOption) (*GetCollectionReply, error) {
	out := new(GetCollectionReply)
	err := c.cc.Invoke(ctx, "/streamsdb.api.Streams/GetCollection", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *streamsClient) Login(ctx context.Context, in *LoginRequest, opts ...grpc.CallOption) (*LoginReply, error) {
	out := new(LoginReply)
	err := c.cc.Invoke(ctx, "/streamsdb.api.Streams/Login", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *streamsClient) EnableAcl(ctx context.Context, in *EnableAclRequest, opts ...grpc.CallOption) (*EnableAclReply, error) {
	out := new(EnableAclReply)
	err := c.cc.Invoke(ctx, "/streamsdb.api.Streams/EnableAcl", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *streamsClient) GrandUserToCollection(ctx context.Context, in *GrandUserToCollectionRequest, opts ...grpc.CallOption) (*GrandUserToCollectionReply, error) {
	out := new(GrandUserToCollectionReply)
	err := c.cc.Invoke(ctx, "/streamsdb.api.Streams/GrandUserToCollection", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *streamsClient) CreateUser(ctx context.Context, in *CreateUserRequest, opts ...grpc.CallOption) (*CreateUserReply, error) {
	out := new(CreateUserReply)
	err := c.cc.Invoke(ctx, "/streamsdb.api.Streams/CreateUser", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *streamsClient) CreateCollection(ctx context.Context, in *CreateCollectionRequest, opts ...grpc.CallOption) (*CreateCollectionReply, error) {
	out := new(CreateCollectionReply)
	err := c.cc.Invoke(ctx, "/streamsdb.api.Streams/CreateCollection", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *streamsClient) Read(ctx context.Context, in *ReadRequest, opts ...grpc.CallOption) (*Slice, error) {
	out := new(Slice)
	err := c.cc.Invoke(ctx, "/streamsdb.api.Streams/Read", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *streamsClient) ReadControl(ctx context.Context, in *ReadRequest, opts ...grpc.CallOption) (*Slice, error) {
	out := new(Slice)
	err := c.cc.Invoke(ctx, "/streamsdb.api.Streams/ReadControl", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *streamsClient) Append(ctx context.Context, in *AppendRequest, opts ...grpc.CallOption) (*AppendReply, error) {
	out := new(AppendReply)
	err := c.cc.Invoke(ctx, "/streamsdb.api.Streams/Append", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *streamsClient) Watch(ctx context.Context, in *ReadRequest, opts ...grpc.CallOption) (Streams_WatchClient, error) {
	stream, err := c.cc.NewStream(ctx, &_Streams_serviceDesc.Streams[0], "/streamsdb.api.Streams/Watch", opts...)
	if err != nil {
		return nil, err
	}
	x := &streamsWatchClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Streams_WatchClient interface {
	Recv() (*Slice, error)
	grpc.ClientStream
}

type streamsWatchClient struct {
	grpc.ClientStream
}

func (x *streamsWatchClient) Recv() (*Slice, error) {
	m := new(Slice)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// StreamsServer is the server API for Streams service.
type StreamsServer interface {
	GetCollection(context.Context, *GetCollectionRequest) (*GetCollectionReply, error)
	Login(context.Context, *LoginRequest) (*LoginReply, error)
	EnableAcl(context.Context, *EnableAclRequest) (*EnableAclReply, error)
	GrandUserToCollection(context.Context, *GrandUserToCollectionRequest) (*GrandUserToCollectionReply, error)
	CreateUser(context.Context, *CreateUserRequest) (*CreateUserReply, error)
	CreateCollection(context.Context, *CreateCollectionRequest) (*CreateCollectionReply, error)
	// Sends a greeting
	Read(context.Context, *ReadRequest) (*Slice, error)
	ReadControl(context.Context, *ReadRequest) (*Slice, error)
	Append(context.Context, *AppendRequest) (*AppendReply, error)
	Watch(*ReadRequest, Streams_WatchServer) error
}

func RegisterStreamsServer(s *grpc.Server, srv StreamsServer) {
	s.RegisterService(&_Streams_serviceDesc, srv)
}

func _Streams_GetCollection_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetCollectionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StreamsServer).GetCollection(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/streamsdb.api.Streams/GetCollection",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StreamsServer).GetCollection(ctx, req.(*GetCollectionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Streams_Login_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LoginRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StreamsServer).Login(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/streamsdb.api.Streams/Login",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StreamsServer).Login(ctx, req.(*LoginRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Streams_EnableAcl_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EnableAclRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StreamsServer).EnableAcl(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/streamsdb.api.Streams/EnableAcl",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StreamsServer).EnableAcl(ctx, req.(*EnableAclRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Streams_GrandUserToCollection_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GrandUserToCollectionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StreamsServer).GrandUserToCollection(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/streamsdb.api.Streams/GrandUserToCollection",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StreamsServer).GrandUserToCollection(ctx, req.(*GrandUserToCollectionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Streams_CreateUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateUserRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StreamsServer).CreateUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/streamsdb.api.Streams/CreateUser",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StreamsServer).CreateUser(ctx, req.(*CreateUserRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Streams_CreateCollection_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateCollectionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StreamsServer).CreateCollection(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/streamsdb.api.Streams/CreateCollection",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StreamsServer).CreateCollection(ctx, req.(*CreateCollectionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Streams_Read_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReadRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StreamsServer).Read(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/streamsdb.api.Streams/Read",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StreamsServer).Read(ctx, req.(*ReadRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Streams_ReadControl_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReadRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StreamsServer).ReadControl(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/streamsdb.api.Streams/ReadControl",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StreamsServer).ReadControl(ctx, req.(*ReadRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Streams_Append_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AppendRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StreamsServer).Append(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/streamsdb.api.Streams/Append",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StreamsServer).Append(ctx, req.(*AppendRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Streams_Watch_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(ReadRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(StreamsServer).Watch(m, &streamsWatchServer{stream})
}

type Streams_WatchServer interface {
	Send(*Slice) error
	grpc.ServerStream
}

type streamsWatchServer struct {
	grpc.ServerStream
}

func (x *streamsWatchServer) Send(m *Slice) error {
	return x.ServerStream.SendMsg(m)
}

var _Streams_serviceDesc = grpc.ServiceDesc{
	ServiceName: "streamsdb.api.Streams",
	HandlerType: (*StreamsServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetCollection",
			Handler:    _Streams_GetCollection_Handler,
		},
		{
			MethodName: "Login",
			Handler:    _Streams_Login_Handler,
		},
		{
			MethodName: "EnableAcl",
			Handler:    _Streams_EnableAcl_Handler,
		},
		{
			MethodName: "GrandUserToCollection",
			Handler:    _Streams_GrandUserToCollection_Handler,
		},
		{
			MethodName: "CreateUser",
			Handler:    _Streams_CreateUser_Handler,
		},
		{
			MethodName: "CreateCollection",
			Handler:    _Streams_CreateCollection_Handler,
		},
		{
			MethodName: "Read",
			Handler:    _Streams_Read_Handler,
		},
		{
			MethodName: "ReadControl",
			Handler:    _Streams_ReadControl_Handler,
		},
		{
			MethodName: "Append",
			Handler:    _Streams_Append_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "Watch",
			Handler:       _Streams_Watch_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "api.proto",
}

func (m *LoginRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LoginRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Username) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Username)))
		i += copy(dAtA[i:], m.Username)
	}
	if len(m.Password) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Password)))
		i += copy(dAtA[i:], m.Password)
	}
	return i, nil
}

func (m *LoginReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LoginReply) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Token) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Token)))
		i += copy(dAtA[i:], m.Token)
	}
	return i, nil
}

func (m *EnableAclRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EnableAclRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Username) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Username)))
		i += copy(dAtA[i:], m.Username)
	}
	if len(m.Password) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Password)))
		i += copy(dAtA[i:], m.Password)
	}
	dAtA[i] = 0x1a
	i++
	i = encodeVarintApi(dAtA, i, uint64(m.Signature.Size()))
	n1, err := m.Signature.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n1
	return i, nil
}

func (m *GetCollectionRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetCollectionRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	return i, nil
}

func (m *GetCollectionReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetCollectionReply) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Id))
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	return i, nil
}

func (m *EnableAclReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EnableAclReply) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *GrandUserToCollectionRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GrandUserToCollectionRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Username) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Username)))
		i += copy(dAtA[i:], m.Username)
	}
	if len(m.Collection) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Collection)))
		i += copy(dAtA[i:], m.Collection)
	}
	return i, nil
}

func (m *GrandUserToCollectionReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GrandUserToCollectionReply) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *CreateUserRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreateUserRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Username) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Username)))
		i += copy(dAtA[i:], m.Username)
	}
	if len(m.Password) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Password)))
		i += copy(dAtA[i:], m.Password)
	}
	return i, nil
}

func (m *CreateUserReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreateUserReply) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *CreateCollectionRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreateCollectionRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	return i, nil
}

func (m *CreateCollectionReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreateCollectionReply) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.CollectionId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.CollectionId))
	}
	return i, nil
}

func (m *ReadRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReadRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.CollectionId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.CollectionId))
	}
	if len(m.Stream) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Stream)))
		i += copy(dAtA[i:], m.Stream)
	}
	if m.From != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.From))
	}
	if m.Count != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Count))
	}
	return i, nil
}

func (m *Message) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Message) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Type) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Type)))
		i += copy(dAtA[i:], m.Type)
	}
	if m.Timestamp != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Timestamp.Size()))
		n2, err := m.Timestamp.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	dAtA[i] = 0x1a
	i++
	i = encodeVarintApi(dAtA, i, uint64(m.Metadata.Size()))
	n3, err := m.Metadata.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n3
	dAtA[i] = 0x22
	i++
	i = encodeVarintApi(dAtA, i, uint64(m.Value.Size()))
	n4, err := m.Value.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n4
	return i, nil
}

func (m *Slice) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Slice) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Stream) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Stream)))
		i += copy(dAtA[i:], m.Stream)
	}
	if m.From != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.From))
	}
	if m.To != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.To))
	}
	if m.Count != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Count))
	}
	if m.Next != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Next))
	}
	if m.HasNext {
		dAtA[i] = 0x30
		i++
		if m.HasNext {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Head != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Head))
	}
	if len(m.Messages) > 0 {
		for _, msg := range m.Messages {
			dAtA[i] = 0x42
			i++
			i = encodeVarintApi(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *MessageInput) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MessageInput) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Type) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Type)))
		i += copy(dAtA[i:], m.Type)
	}
	dAtA[i] = 0x12
	i++
	i = encodeVarintApi(dAtA, i, uint64(m.Metadata.Size()))
	n5, err := m.Metadata.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n5
	dAtA[i] = 0x1a
	i++
	i = encodeVarintApi(dAtA, i, uint64(m.Value.Size()))
	n6, err := m.Value.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n6
	return i, nil
}

func (m *AppendRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AppendRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.CollectionId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.CollectionId))
	}
	if len(m.Stream) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Stream)))
		i += copy(dAtA[i:], m.Stream)
	}
	if len(m.Messages) > 0 {
		for _, msg := range m.Messages {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintApi(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *AppendReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AppendReply) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.From != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.From))
	}
	return i, nil
}

func encodeVarintApi(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *LoginRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Username)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.Password)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	return n
}

func (m *LoginReply) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Token)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	return n
}

func (m *EnableAclRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Username)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.Password)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = m.Signature.Size()
	n += 1 + l + sovApi(uint64(l))
	return n
}

func (m *GetCollectionRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	return n
}

func (m *GetCollectionReply) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovApi(uint64(m.Id))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	return n
}

func (m *EnableAclReply) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *GrandUserToCollectionRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Username)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.Collection)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	return n
}

func (m *GrandUserToCollectionReply) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *CreateUserRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Username)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.Password)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	return n
}

func (m *CreateUserReply) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *CreateCollectionRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	return n
}

func (m *CreateCollectionReply) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CollectionId != 0 {
		n += 1 + sovApi(uint64(m.CollectionId))
	}
	return n
}

func (m *ReadRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CollectionId != 0 {
		n += 1 + sovApi(uint64(m.CollectionId))
	}
	l = len(m.Stream)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.From != 0 {
		n += 1 + sovApi(uint64(m.From))
	}
	if m.Count != 0 {
		n += 1 + sovApi(uint64(m.Count))
	}
	return n
}

func (m *Message) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.Timestamp != nil {
		l = m.Timestamp.Size()
		n += 1 + l + sovApi(uint64(l))
	}
	l = m.Metadata.Size()
	n += 1 + l + sovApi(uint64(l))
	l = m.Value.Size()
	n += 1 + l + sovApi(uint64(l))
	return n
}

func (m *Slice) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Stream)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.From != 0 {
		n += 1 + sovApi(uint64(m.From))
	}
	if m.To != 0 {
		n += 1 + sovApi(uint64(m.To))
	}
	if m.Count != 0 {
		n += 1 + sovApi(uint64(m.Count))
	}
	if m.Next != 0 {
		n += 1 + sovApi(uint64(m.Next))
	}
	if m.HasNext {
		n += 2
	}
	if m.Head != 0 {
		n += 1 + sovApi(uint64(m.Head))
	}
	if len(m.Messages) > 0 {
		for _, e := range m.Messages {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	return n
}

func (m *MessageInput) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = m.Metadata.Size()
	n += 1 + l + sovApi(uint64(l))
	l = m.Value.Size()
	n += 1 + l + sovApi(uint64(l))
	return n
}

func (m *AppendRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CollectionId != 0 {
		n += 1 + sovApi(uint64(m.CollectionId))
	}
	l = len(m.Stream)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if len(m.Messages) > 0 {
		for _, e := range m.Messages {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	return n
}

func (m *AppendReply) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.From != 0 {
		n += 1 + sovApi(uint64(m.From))
	}
	return n
}

func sovApi(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozApi(x uint64) (n int) {
	return sovApi(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *LoginRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LoginRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LoginRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Username", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Username = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Password", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Password = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LoginReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LoginReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LoginReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Token", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Token = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EnableAclRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EnableAclRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EnableAclRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Username", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Username = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Password", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Password = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Signature", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Signature.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetCollectionRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetCollectionRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetCollectionRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetCollectionReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetCollectionReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetCollectionReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EnableAclReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EnableAclReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EnableAclReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GrandUserToCollectionRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GrandUserToCollectionRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GrandUserToCollectionRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Username", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Username = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Collection", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Collection = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GrandUserToCollectionReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GrandUserToCollectionReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GrandUserToCollectionReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreateUserRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateUserRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateUserRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Username", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Username = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Password", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Password = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreateUserReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateUserReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateUserReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreateCollectionRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateCollectionRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateCollectionRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreateCollectionReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateCollectionReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateCollectionReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CollectionId", wireType)
			}
			m.CollectionId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CollectionId |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReadRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReadRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReadRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CollectionId", wireType)
			}
			m.CollectionId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CollectionId |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stream", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Stream = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field From", wireType)
			}
			m.From = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.From |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Count", wireType)
			}
			m.Count = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Count |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Message) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Message: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Message: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Timestamp == nil {
				m.Timestamp = &types.Timestamp{}
			}
			if err := m.Timestamp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metadata", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Metadata.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Value.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Slice) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Slice: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Slice: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stream", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Stream = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field From", wireType)
			}
			m.From = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.From |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field To", wireType)
			}
			m.To = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.To |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Count", wireType)
			}
			m.Count = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Count |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Next", wireType)
			}
			m.Next = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Next |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HasNext", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.HasNext = bool(v != 0)
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Head", wireType)
			}
			m.Head = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Head |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Messages", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Messages = append(m.Messages, &Message{})
			if err := m.Messages[len(m.Messages)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MessageInput) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MessageInput: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MessageInput: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metadata", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Metadata.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Value.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AppendRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AppendRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AppendRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CollectionId", wireType)
			}
			m.CollectionId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CollectionId |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stream", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Stream = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Messages", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Messages = append(m.Messages, &MessageInput{})
			if err := m.Messages[len(m.Messages)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AppendReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AppendReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AppendReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field From", wireType)
			}
			m.From = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.From |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipApi(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowApi
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowApi
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowApi
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthApi
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowApi
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipApi(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthApi = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowApi   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("api.proto", fileDescriptor_api_f7ebe764f5fe0ecb) }
func init() { golang_proto.RegisterFile("api.proto", fileDescriptor_api_f7ebe764f5fe0ecb) }

var fileDescriptor_api_f7ebe764f5fe0ecb = []byte{
	// 877 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0x55, 0xcf, 0x6f, 0xdc, 0x44,
	0x14, 0xde, 0xf1, 0x66, 0x37, 0xd9, 0x97, 0x1f, 0xa4, 0xa3, 0xb4, 0x18, 0x13, 0x9c, 0xad, 0x41,
	0x28, 0x05, 0xc5, 0x0b, 0xe1, 0x40, 0x05, 0x42, 0x28, 0x09, 0x10, 0x55, 0x10, 0x40, 0x6e, 0x51,
	0xa5, 0xde, 0x66, 0xd7, 0x53, 0xc7, 0xe0, 0xf5, 0xb8, 0x9e, 0x71, 0x4b, 0x6e, 0x1c, 0xf8, 0x03,
	0xb8, 0x73, 0xe0, 0xff, 0xe0, 0xc4, 0x31, 0x37, 0x7a, 0x44, 0x1c, 0x2a, 0x94, 0xfd, 0x03, 0xb8,
	0x72, 0x44, 0x33, 0x63, 0x7b, 0xbd, 0xce, 0x66, 0x1b, 0x6d, 0x72, 0x9b, 0x37, 0xf3, 0xbd, 0xef,
	0xcd, 0x7c, 0xf3, 0xe6, 0x1b, 0xe8, 0x90, 0x24, 0x74, 0x93, 0x94, 0x09, 0x86, 0x57, 0xb9, 0x48,
	0x29, 0x19, 0x72, 0xbf, 0xef, 0x92, 0x24, 0xb4, 0x76, 0x82, 0x50, 0x1c, 0x67, 0x7d, 0x77, 0xc0,
	0x86, 0xbd, 0x80, 0x05, 0xac, 0xa7, 0x50, 0xfd, 0xec, 0xb1, 0x8a, 0x54, 0xa0, 0x46, 0x3a, 0xdb,
	0xda, 0x0a, 0x18, 0x0b, 0x22, 0x3a, 0x46, 0x89, 0x70, 0x48, 0xb9, 0x20, 0xc3, 0x44, 0x03, 0x9c,
	0x2f, 0x60, 0xe5, 0x2b, 0x16, 0x84, 0xb1, 0x47, 0x9f, 0x64, 0x94, 0x0b, 0x6c, 0xc1, 0x52, 0xc6,
	0x69, 0x1a, 0x93, 0x21, 0x35, 0x51, 0x17, 0x6d, 0x77, 0xbc, 0x32, 0x96, 0x6b, 0x09, 0xe1, 0xfc,
	0x19, 0x4b, 0x7d, 0xd3, 0xd0, 0x6b, 0x45, 0xec, 0x38, 0x00, 0x39, 0x4f, 0x12, 0x9d, 0xe0, 0x0d,
	0x68, 0x09, 0xf6, 0x03, 0x8d, 0x73, 0x0a, 0x1d, 0x38, 0xbf, 0x22, 0x58, 0xff, 0x3c, 0x26, 0xfd,
	0x88, 0xee, 0x0d, 0xa2, 0x2b, 0x16, 0xc4, 0xdf, 0x40, 0x87, 0x87, 0x41, 0x4c, 0x44, 0x96, 0x52,
	0xb3, 0xd9, 0x45, 0xdb, 0x2b, 0xfb, 0xef, 0x9f, 0xbe, 0xd8, 0x6a, 0xfc, 0xfd, 0x62, 0xeb, 0x4e,
	0x45, 0xa3, 0xe4, 0xfb, 0xa7, 0x3e, 0xef, 0x95, 0x1a, 0xf6, 0x48, 0x12, 0xf6, 0x9e, 0x85, 0x29,
	0x75, 0xf7, 0x4f, 0x04, 0xe5, 0xde, 0x98, 0xc3, 0x79, 0x07, 0x36, 0x0e, 0xa9, 0x38, 0x60, 0x51,
	0x44, 0x07, 0x22, 0x64, 0xa5, 0x22, 0x18, 0x16, 0x2a, 0x9b, 0x53, 0x63, 0xe7, 0x2e, 0xe0, 0x1a,
	0x56, 0x9e, 0x7a, 0x0d, 0x8c, 0xd0, 0x57, 0xb8, 0x55, 0xcf, 0x08, 0xfd, 0x32, 0xd3, 0xa8, 0x64,
	0xae, 0xc3, 0x5a, 0x45, 0x82, 0x24, 0x3a, 0x71, 0x1e, 0xc1, 0xe6, 0x61, 0x4a, 0x62, 0xff, 0x3b,
	0x4e, 0xd3, 0x07, 0xec, 0x7c, 0xfd, 0x59, 0x02, 0xd9, 0x00, 0x83, 0x32, 0x21, 0xaf, 0x53, 0x99,
	0x71, 0x36, 0xc1, 0xba, 0x80, 0x5b, 0x56, 0xfe, 0x12, 0x6e, 0x1c, 0xa4, 0x94, 0x08, 0x2a, 0x97,
	0xaf, 0xda, 0x00, 0x37, 0xe0, 0x95, 0x2a, 0x99, 0xe4, 0xdf, 0x81, 0x57, 0xf5, 0xd4, 0xe5, 0x44,
	0xfd, 0x18, 0x6e, 0x9e, 0x87, 0x4b, 0x5d, 0x1d, 0x58, 0x19, 0x9f, 0xe9, 0x5e, 0xa1, 0xf0, 0xc4,
	0x9c, 0xc3, 0x61, 0xd9, 0xa3, 0xc4, 0x2f, 0xf8, 0x2f, 0x91, 0x82, 0x6f, 0x41, 0x5b, 0xf7, 0x45,
	0x7e, 0x96, 0x3c, 0x92, 0x7b, 0x7b, 0x9c, 0xb2, 0xa1, 0x6a, 0xaa, 0xa6, 0xa7, 0xc6, 0xb2, 0xa1,
	0x07, 0x2c, 0x8b, 0x85, 0xb9, 0xa0, 0x88, 0x74, 0xe0, 0xfc, 0x8b, 0x60, 0xf1, 0x88, 0x72, 0x4e,
	0x02, 0x2a, 0xb3, 0xc4, 0x49, 0x52, 0x9e, 0x48, 0x8e, 0xf1, 0x5d, 0xe8, 0x94, 0xef, 0x4d, 0x15,
	0x59, 0xde, 0xb5, 0x5c, 0xfd, 0x22, 0xdd, 0xe2, 0x45, 0xba, 0x0f, 0x0a, 0x84, 0x37, 0x06, 0xe3,
	0x23, 0x58, 0x1a, 0x52, 0x41, 0x7c, 0x22, 0xc8, 0xfc, 0xcd, 0x5d, 0x52, 0xe0, 0x43, 0x68, 0x3d,
	0x25, 0x51, 0x46, 0xd5, 0xf6, 0xe7, 0xe2, 0xd2, 0xf9, 0xce, 0x9f, 0x08, 0x5a, 0xf7, 0xa3, 0x70,
	0x40, 0x2b, 0xea, 0xa1, 0xa9, 0xea, 0x19, 0x15, 0xf5, 0xd6, 0xc0, 0x10, 0x2c, 0xd7, 0xd3, 0x10,
	0x6c, 0x52, 0xcd, 0x56, 0xae, 0xa6, 0xea, 0x09, 0xfa, 0xa3, 0x30, 0x5b, 0x3a, 0x53, 0x8e, 0xb1,
	0x09, 0x8b, 0xc7, 0x84, 0x7f, 0x2d, 0xa7, 0xdb, 0x5d, 0xb4, 0xbd, 0xe4, 0x15, 0xa1, 0x44, 0x1f,
	0x53, 0xe2, 0x9b, 0x8b, 0x1a, 0x2d, 0xc7, 0x78, 0x57, 0xaa, 0xa6, 0xae, 0x83, 0x9b, 0x4b, 0xdd,
	0xe6, 0xf6, 0xf2, 0xee, 0x2d, 0x77, 0xc2, 0x3e, 0xdd, 0xfc, 0xb6, 0xbc, 0x12, 0xe7, 0xfc, 0x8e,
	0x60, 0x25, 0x9f, 0xbd, 0x17, 0x27, 0x99, 0x98, 0x7a, 0x91, 0xd5, 0xeb, 0x30, 0xae, 0xf1, 0x3a,
	0x9a, 0x57, 0xbc, 0x8e, 0x9f, 0x11, 0xac, 0xee, 0x25, 0x09, 0x8d, 0xaf, 0xa5, 0xf1, 0x3f, 0xac,
	0xc8, 0xd7, 0x54, 0xf2, 0xbd, 0x3e, 0x5d, 0x3e, 0x25, 0x54, 0x45, 0xc3, 0xdb, 0xb0, 0x5c, 0xec,
	0x42, 0xbe, 0xd7, 0xa2, 0x05, 0xd0, 0xb8, 0x05, 0x76, 0x7f, 0x6b, 0xc3, 0xe2, 0x7d, 0xcd, 0x85,
	0x1f, 0xc2, 0xea, 0x84, 0x7b, 0xe2, 0x37, 0x6b, 0x65, 0xa6, 0xf9, 0xb0, 0x75, 0x7b, 0x36, 0x48,
	0x16, 0xfe, 0x14, 0x5a, 0xea, 0x13, 0xc2, 0xf5, 0x7d, 0x57, 0xbf, 0x38, 0xeb, 0xb5, 0xe9, 0x8b,
	0x92, 0xe0, 0x08, 0x3a, 0xa5, 0x3b, 0xe3, 0xad, 0x1a, 0xae, 0xfe, 0x75, 0x59, 0x6f, 0x5c, 0x0c,
	0x90, 0xf6, 0xd7, 0xc0, 0x4f, 0xe0, 0xe6, 0x54, 0xfb, 0xc5, 0xef, 0xd6, 0xcf, 0x32, 0xe3, 0x03,
	0xb0, 0xee, 0x5c, 0x0e, 0xac, 0x4b, 0x7e, 0x0b, 0x30, 0xb6, 0x61, 0xdc, 0xad, 0xa5, 0x9e, 0xb3,
	0x7b, 0xcb, 0x9e, 0x81, 0xd0, 0x8c, 0x7d, 0x58, 0xaf, 0xdb, 0x32, 0x7e, 0x7b, 0x6a, 0xd6, 0xf9,
	0xad, 0xbf, 0xf5, 0x52, 0x9c, 0xae, 0xf1, 0x11, 0x2c, 0x48, 0xf7, 0xc6, 0x56, 0x0d, 0x5f, 0xb1,
	0x74, 0x6b, 0xa3, 0xb6, 0xa6, 0x6c, 0xc8, 0x69, 0xe0, 0x3d, 0xed, 0xfc, 0x07, 0x2c, 0x16, 0x29,
	0x8b, 0xe6, 0xa2, 0xf8, 0x0c, 0xda, 0xba, 0x7f, 0xf1, 0x66, 0x0d, 0x31, 0xf1, 0xb8, 0x2c, 0xeb,
	0x82, 0x55, 0x7d, 0x88, 0x4f, 0xa0, 0xf5, 0x90, 0x88, 0xc1, 0xf1, 0x3c, 0x5b, 0x78, 0x0f, 0xed,
	0xef, 0x9c, 0x9e, 0xd9, 0xe8, 0xf9, 0x99, 0x8d, 0xfe, 0x39, 0xb3, 0xd1, 0x7f, 0x67, 0x36, 0xfa,
	0x69, 0x64, 0xa3, 0x5f, 0x46, 0x76, 0xe3, 0x8f, 0x91, 0x8d, 0x4e, 0x47, 0x76, 0xe3, 0xf9, 0xc8,
	0x6e, 0xfc, 0x35, 0xb2, 0x1b, 0x8f, 0x9a, 0x24, 0x09, 0xfb, 0x6d, 0xf5, 0x81, 0x7c, 0xf0, 0x7f,
	0x00, 0x00, 0x00, 0xff, 0xff, 0x6b, 0xc6, 0xce, 0x54, 0x2b, 0x0a, 0x00, 0x00,
}
